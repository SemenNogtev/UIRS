unsigned long TPeriod = 1; // шаг расчета, 1 мс
unsigned int k = 0; // счетчик вывода

double dt = TPeriod*0.001; // шаг расчета апериодического звена, 1 мс
double T = 0.1; // постоянная времени апериодического звена, с
double y = 0, y0 = 0; // начальные условия апериодического звена

void aperiodic(double x, double dt);

void setup(){
    pinMode(13, OUTPUT);
    Serial.begin(9600);
 
    // инициализация Timer1
    cli();  // отключить глобальные прерывания

    TCCR1A = 0;   // установить регистр в 0
    TCCR1B = 0;   // установить регистр в 0

    // Таймер переполняться каждые 65535 отсчетов при коэффициенте деления 1024 или за 4,194с
    OCR1A = 1562; // установка регистра совпадения (0,1 секунда)
 
    TCCR1B |= (1 << WGM12);  // включить CTC режим > сброс таймера по совпадению
    TCCR1B |= (1 << CS10);   // Установить биты CS10 CS12 на коэффициент деления 1024
    TCCR1B |= (1 << CS12);
 
    // F (ПРЕРЫВАНИЙ) = 16000000 / (1024 *(1 + 15624)) = 1 
 
    TIMSK1 |= (1 << OCIE1A);  // включить прерывание по совпадению таймера
    
    sei(); // включить глобальные прерывания   
}
 
void loop(){

}
 
ISR(TIMER1_COMPA_vect)// Вызывается ISR(TIMER1_OVF_vect), это происходит всегда когда таймер переполняется
{
    digitalWrite(13, !digitalRead(13));
    if((k%10==0)&&(k<500)) Serial.println(y);
    k++;
    aperiodic(1, dt);
}

void aperiodic(double x, double dt)
{
  y = y0+1/T*(x-y0)*dt;
  y0 = y;
}
